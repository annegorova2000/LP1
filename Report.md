# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Егорова А.В. 

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки – основная структура данных, применяемая в языке Пролог, они являются основой для организации всех сложных вычислений. Одно из основных свойств списка – отсутствие ограничений на элементы и размер списка. Вложенность списков также ничем не ограничивается. Список в языке трактуется как структура из двух элементов – «головы» и «хвоста». Это разделение является основой вычислений над списками. От принятых в императивных языках подходов к хранению данных списки Пролога отличаются, в первую очередь, произвольным типом элементов, такое свободное отношение к типам редко в императивных языках. Списки Пролога очень похожи на бинарные деревья, с тем допущением, что каждый узел имеет лист.

## Задание 1.1: Предикат обработки списка

Усечение списка до указанной длины с использованием стандартный предикатов
```
truncation(List,Length,Result)
```
Усечение списка до указанной длины без стандартных предикатов
```
truncation2(List,Length,Result) 
```
Примеры использования:
```
?- truncation([1,4,5,6,78,0,4],3,Result).
Result = [1, 4, 5].

?- truncation2([1,2,3,4,5,6],5,Result).
Result = [1, 2, 3, 4, 5].
```
Реализация:
```
truncation(List,Length,Result):-append(Result, _, List), length(Result, Length), !.
```
С помощью append'а рассматриваем все возможности разбиения списка, а с помощью length находим разбиение нужной длины.
```
truncation2(_,0,[]).
truncation2([ListHead|ListTail],Length,[ListHead|ResultTail]):-
	Length1 is Length - 1,
	truncation2(ListTail, Length1, ResultTail),!.
 ``` 
Рекурсивно задаем, пока длина не нуль и результат не пуст, убираем один левый элемент результата и изначального списка, при условии, что они равны, и уменьшаем длину на единицу.

## Задание 1.2: Предикат обработки числового списка

Вычисление позиции минимального элемента в списке с использованием стандартных предикатов
```
minElemPos(List,Pos) 
```
Версия без использования стандартных предикатовВерсия без использования стандартных предикатов
```
minElemPos2(List,Pos) 
```
Примеры использования:
```
?- minElemPos([5,4,3,2,1,2,3,4,5],Pos).
Pos = 4.

?- minElemPos2([1,2,-99,3],Pos).
Pos = 2.
```
Реализация:
```
minElemPos(List,Pos):-min_list(List,MinElem), nth0(Pos,List,MinElem), !.
```
С помощью min_list находим минимальный элемент, с помощью nth0 находим позицию этого элемента.
```
minElemPos2(List,Pos):-
    minForList(List,Min),
    minPosForList(List,0,Pos,Min),!.

minPosForList([Min|_],Pos,Pos,Min).
minPosForList([_|Ls],Pos1,Pos,Min):-
    Pos2 is Pos1+1,
    minPosForList(Ls,Pos2,Pos,Min).

minForTwo(X,Y,X):- X=<Y, !.
minForTwo(X,Y,Y):- X>Y.

minForList([L|Ls], Min) :-
    minForList(Ls, L, Min).

minForList([], Min, Min).
minForList([Head|Tail], Min0, Min):-
    Min1 is min(Head,Min0),
    minForList(Tail, Min1, Min).
   ``` 
Для поиска без использование реализуем поиск минимального элемента в списке, для этого реализуем выбор минимального из двух элементов, использовав стандартное сравнение элементов языка пролог. Затем, напишем поиск позиции минимального элемента.

Задание 1.3: Пример совместного использования
 Предикат, который отсекает список до минимального элемента.
```
truncationSpec(List,Result)
```
Примеры использования:
```
?- truncationSpec([1,2,-99,3],Result).
Result = [1, 2].

?- truncationSpec([-99,1,2,3,4],Result).
Result = [].
```
Реализация:
```
truncationSpec(List,Result):-
        minElemPos(List,Pos),truncation(List,Pos,Result).
```   
Находим позицию позицию минимального элемента и используем её, как длину для отсечения.

## Задание 2: Реляционное представление данных

Реляционное программирование — это описание отношений между аргументами и результатом. Сам термин «реляционный» означает, что теория основана на понятии отношениях (relation) между объектами. Следовательно, главной задачей программиста является создание программы, способной проводить анализ этих отношений. Несомненными достоинствами реляционного подхода являются простота, теоретическое обоснование и независимость данных. Из недостатков стоит отметить низкую скорость при выполнении операции соединения. 

Моя таблица занимает немного места: в каждой строке со студентом присутствует список с оценками. Но в тоже время, просмотр таблицы не совсем удобен. Поиск по таблицы будет не удобен так как при сопостовлении каких-либо придметов приходится пробегать по всем ученикам и у каждого ученика нужно пробегать по оценкам. Да, наверное компакность этой таблицы будет иметь плюсы по скорости, при определенных запросах к базе данных.


Задание 2.1: Для каждого студента, найти средний балл, и сдал ли он экзамены или нет.
Для каждого студента, найти средний балл
```
averageMark(Stud,Mark)
```
Сдал ли студент экзамены
```
passExams(Stud)
```

Примеры использования:
```
?- averageMark('Петров',X).
X = 4.

?- averageMark('Петровский',X).
X = 3.6666666666666665.

?- averageMark(X,4).
X = 'Петров' ;
X = 'Иванов' ;
X = 'Сидоров' ;
X = 'Биткоинов' ;
X = 'Программиро' ;
X = 'Круглотличников'.

?- passExams('Петров').
true.

?- passExams('Азурин').
false.
```
Реализация:

%2.1 Для каждого студента, найти средний балл, и сдал ли он экзамены или нет
%(Студент, Средняя оценка)
```
averageMark(Stud,Mark):-
	student(_,Stud,Z),
	sum(Z, Sum),
	length(Z,Len),
	Mark is Sum / Len.
```
%Cумма всех элементов в списке
%(Список, Сумма)
```
sum([grade(_, H)|T],N):-
	sum(T,N1),
	N is N1+H.
sum([],0).
```
%Сдал ли студент экзамены
%Если хотя бы одна двойка, то false
%(Студент)
```
passExams(Stud):-
	student(_,Stud,Marks),
	not(member(grade(_,2),Marks)).
```
Для поиска средней оценки находяться все оценки студента, суммируются и cумма делится на их количество.
Для выяснения сдал ли студент, ищутся все его оценки и проверятся наличие среди них двоек.


Задание 2.2: Для каждого предмета, найти количество не сдавших студентов
Для каждого предмета, найти количество не сдавших студентов
```
countOfFailed(Subj,N) 
```
Примеры использования:
```
?- countOfFailed('Математический анализ',X).
X = 3.

?- countOfFailed('Английский язык',X).
X = 2.
```
Реализация:

%2.2 Для каждого предмета, найти количество не сдавших студентов
%(Предмет, количество)
```
countOfFailed(Subj,N):-
	subject(Ss,Subj),
	findall(A,(student(_,_,A),gradeInList(A,Ss)),AllMarks),
	length(AllMarks,N).

gradeInList([grade(Subj,2)|_],Subj).
gradeInList([_|Tail],Subj):-
	gradeInList(Tail,Subj).
```
Для предмета находится множество (без повторений!) учеников у которых двойка по этому предмету. Длина этого списка-множества искомое.

Задание 2.3: Для каждой группы, найти студента (студентов) с максимальным средним баллом
Для каждой группы, найти студента (студентов) с максимальным средним баллом
```
bestStudent(Group,N) 
```
Примеры использования:
```
?- bestStudent(101,L).
L = ['Безумников', 'Густобуквенникова'].

?- bestStudent(102,L).
L = ['Азурин'].

?- bestStudent(103,L).
L = ['Вебсервисов'].

?- bestStudent(104,L).
L = ['Фулл'].
```
Реализация:

%2.3 Для каждой группы, найти студента (студентов) с максимальным средним баллом
%(Группа, Список учеников с максимальным средним баллом)
```
bestStudent(Group,N):-
```
  %собираем список со всеми средними оценками
  ```
  findall(Mark, (student(Group,Stud,_), averageMark(Stud,Mark)),Marks),
  ```
  %находим максимальную из них
  ```
  max(Marks,Max),
  ```
  %составляем список из всех студентов имеющих такую оценку
  ```
  findall(A,(student(Group,A,_), averageMark(A,M), M==Max), N), !.
```
%Нахождение максимального из положительного числового списка
%(Список, максимум)
```
max([],0).
max([H|T],N):-
  max(T,B),
  H =< B,
  N is B.
max([H|T],N):-
  max(T,B),
  H >= B,
  N is H.
  ```
Сперва ищется максимальная средняя оценка по группе: находиться список со всеми оценками и выделяется максимальная. Затем собирается список со всеми учениками, имеющими эту максимальную оценку.

## Выводы

Пролог — язык логического программирования. Читать программы на прологе просто, так как в языке очень мало специальных символов и ключевых слов и они легко переводятся на естественный язык. Думаю, трудности с ним могут возникнуть только при попытке сразу представить как работает программа, а не прочитать, что она описывает. В языке существует 2 понятия предикаты (условия) и объекты (они же переменные и термы). Предикаты выражают некоторое условие, которое имеет входные параметры. Например green_object(Object), prime_number(Number) . Сколько в предикате параметров, такова и арность предиката. Объектами — являются термы, константы и переменные. Константы — это числа и строки, переменные — выражают неизвестный объект. ПРОЛОГ имеет два основных отличия от процедурных языков — способ организации вычислений и способ представления данных. Оба этих аспекта языка коренным образом отличаются от традиционных языков программирования. Но стоит помнить, что логическое программирование реализуется на тех же машинах с фон — Неймановской архитектурой. Во время составления программ я много времени уделила использованию трассировки, что помогло мне лучше понять логику Пролога, как он думает, и вникнуть в механизм бэктрекинга. Пролог, для меня, оказался неожиданно мощным средством решения задач, я продолжу более глубокое изучение его механизмов.




